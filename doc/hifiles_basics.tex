\documentclass[letter,10pt]{article}
\usepackage[left = 2.5cm,right=1.85cm,
top=2.5cm,bottom=2cm,noheadfoot]{geometry}
\usepackage{setspace,url,amsmath,verbatim,float,gensymb,subfig,graphicx,enumerate}
\newcommand{\f}[2]{\frac{#1}{#2}}
\newcommand{\abs}[1]{\left|#1\right|}
\newcommand{\degr}[0]{\text{\textdegree}}

\renewcommand{\labelitemi}{$\bullet$}
\renewcommand{\labelitemii}{$\cdot$}
\renewcommand{\labelitemiii}{$\diamond$}
\renewcommand{\labelitemiv}{$\ast$}

\newcommand*{\TitleFont}{%
      \usefont{\encodingdefault}{\rmdefault}{b}{n}%
      \fontsize{10}{20}%
      \selectfont}



\title{\TitleFont{\vspace{-1cm}\bf{HiFiLES Quick Reference Guide \vspace{-2cm}}}}
\date{}
\begin{document}
\begin{flushleft}
Aerospace Computing Laboratory\\
Prepared by Manuel R. L\'opez \& Thomas D. Economon\\
November 2013
\end{flushleft}

\begingroup
\let\newpage\relax% Void the actions of \newpage
\let\date\relax
\let\author\relax
\maketitle
\endgroup
\pagenumbering{gobble}

\section*{\TitleFont{Developing HiFiLES through Git + GitHub}}

The repository for HiFiLES is being hosted on GitHub (\url{https://github.com}). GitHub is simply an online project hosting service with a useful web interface and additional tools to aid code development with Git as its backbone. Git is a version control system (VCS) which is similar to SVN, Mercurial, etc., and it helps organize the development of code over time by tracking changes. 

To get started, you need to create a personal user account on GitHub (free) and to follow the basic setup instructions at
\url{https://help.github.com/articles/set-up-git}. These instructions include how to get Git installed on your local machine. To sync up your local settings with GitHub, change the user.email and user.name variables for your local git configuration with
\begin{verbatim}git config --global user.email "enterYourEmailAddressBetweenQuotationMarks" 
git config --global user.name "enterYourNameBetweenQuotationMarks"
\end{verbatim}
Note that the email address should be the one associated with your GitHub account.  If already have a separate GitHub account setup on your computer, you can change the user settings for just the HiFiLES repository by \texttt{cd}'ing to your HiFiLES working directory, and using the above commands, but without the \texttt{--global} flag.  Additionally, if you don't want Git to ask for your username and password every time you access the remote server, you can tell Git to keep your credentials saved for a short period of time (15 minutes by default):
\begin{verbatim}
git config --global credential.helper cache
\end{verbatim}
HiFiLES is currently under a private repository (this location will change if/when the code goes publicly open-source), and the main page for the project is located here: \url{https://github.com/fpalacios/HiFiLES}. The web interface is useful for viewing the recent commits to the code, changes to the code over time, or creating and viewing branches, for instance. To contribute to HiFiLES, an administrator for the project must add you as a member of the developer team with push and pull privileges (ask Francisco Palacios). 

Most of the day-to-day development of the code will be done on your local machine at the command line using Git. After setting up Git and gaining access to the HiFiLES repository, create a local copy of the entire repository on your machine by cloning the version that is hosted on GitHub:
\begin{verbatim}
git clone https://github.com/fpalacios/HiFiLES.git
\end{verbatim}
After cloning, you should have a new HiFiLES/ folder in your current working directory. Move into HiFiLES/ to see the project files and to start working with the code through Git. You can see the most recent changes by typing
\begin{verbatim}
git log
\end{verbatim}

\section*{\TitleFont{Typical Workflow with Git}}

Now that you have a local copy of HiFiLES from the GitHub repository, you can begin to make changes to the codebase. This section gives an example of the typical workflow for making changes to the code, committing them locally, and then pushing your changes to the remote GitHub repository. The basic steps are as follows:

\begin{enumerate}
 
 \item Make changes to the existing files (using your favorite text editor or integrated development environment, IDE) or add local files or folders to be tracked and compared against the global repo files
\begin{verbatim}
git add file1.cpp file2.cpp /folder_directory1 /folder_directory2
\end{verbatim}

\item Check that your changes have been registered and/or the files that you want have been added added
\begin{verbatim}
git status 
\end{verbatim}\hline

\item Commit the changes to your local repository (not the
global repository on GitHub) and leave a short descriptive message about your change. 
\begin{verbatim}
git commit -am "Added some files and folders."
\end{verbatim}

\item Merge local and global repositories.
 This command will attempt to merge your version of the code with the global
version. Near the end of the merger process, git will tell you if everything has
been merged successfully. If there are conflicts, it will tell you the files
which contain the conflicts. You must then navigate to these files, open them,
and resolve the conflicts. The conflicting regions of code are delimited with
chevrons like this \texttt{>>>>>>>>>>>>>>>} and \texttt{<<<<<<<<<<<<<<}.
\begin{verbatim}
git pull origin master
\end{verbatim}

\item Push the final version of the code to the global repository on GitHub (the remote repository is named `origin' by default). The changes you have made will now be available to all, and they will also be almost immediately reflected on the HiFiLES page on GitHub.
\begin{verbatim}
git push origin master 
\end{verbatim}

\end{enumerate}

\section*{\TitleFont{Branching in Git}}

The ease of code branching is a major feature in Git. Branches are parallel versions of the code that allow for decentralized development of particular features or fixes. In this manner, an individual or team can easily switch between developing different features in the code and merge them into the master version when ready (can also help avoid conflicts). In fact, while not mentioned above, the master version of the code is simply a branch like any other. To see the branches in your local repository, type
\begin{verbatim}
git branch
\end{verbatim}
The branch name with an asterisk is the current working branch. One can add branches locally or globally to the remote repository on GitHub that can be shared by all. Assume that a new branch named `feature\_new' has been created in the remote repository, either through the command line or through the GitHub web interface, and you would like to work on this feature. A typical workflow in this scenario might be:

\begin{enumerate}

\item Clone a fresh copy of HiFiLES or update your current version with the latest changes on the remote repository.
\begin{verbatim}
git pull
\end{verbatim}
If you would just like to make your local repository aware of changes in the remote (such as the addition of the `feature\_new' branch) but don't want any changes to local files, you could use
\begin{verbatim}
git fetch
\end{verbatim}

\item Create a local copy of the branch that is linked to the version on the remote repository,
\begin{verbatim}
git checkout -b feature_new origin/feature_new
\end{verbatim}
This command creates the local branch and switches your local working copy to the `feature\_new' branch. Note that you can not have any local edits or changes when switching between branches, so you should either make a local commit of your changes (as described above) or revert all local changes in the repository with
\begin{verbatim}
git checkout -- .
\end{verbatim}

\item Check that you are now in the `feature\_new' branch with
\begin{verbatim}
git branch
\end{verbatim}
You should notice that the local copies of your files have seamlessly switched to their state under the `feature\_new' branch.

\item Make some changes to the code and commit your changes to your local copy of the `feature\_new' branch as usual
\begin{verbatim}
git commit -am "Updates."
\end{verbatim}

\item Merge local and remote versions of the branch and fix any conflicts if necessary,
\begin{verbatim}
git pull origin feature_new
\end{verbatim}

\item Push the final version of the code to the remote branch on GitHub to make it available to all,
\begin{verbatim}
git push origin feature_new 
\end{verbatim}

\end{enumerate}

It is often the case that you would like to merge your branches back into the master branch after completing work on your new feature or bug fix. When developing features that may take an extended amount of time, it is a good idea to update your branch frequently with the recent changes in the master. This will make it much easier to merge the branches eventually and will help avoid conflicts and headaches when the time comes. Let's assume you are about to work on the `feature\_new' branch again, but would like to update it with the most recent work in the master branch. You could do the following (there are multiple ways to push/pull things between branches):

\begin{enumerate}

\item Move back over into your local copy of the master branch
\begin{verbatim}
git checkout master
\end{verbatim}

\item Check that you are back in the master branch with
\begin{verbatim}
git branch
\end{verbatim}

\item Pull the latest and greatest from the remote master branch on GitHub. Your local copy of the master branch now has all recent changes that can be shared with other local branches.
\begin{verbatim}
git pull origin master
\end{verbatim}

\item Switch back over to your local copy of the `feature\_new' branch
\begin{verbatim}
git checkout feature_new
\end{verbatim}

\item Merge the local version of the master branch that you just updated into your local version of `feature\_new' and fix any conflicts if necessary.
\begin{verbatim}
git merge master
\end{verbatim}

\item Make code changes, merge with the remote `feature\_new' branch, and push to the remote `feature\_new' branch like usual
\begin{verbatim}
git commit -am "More updates."
git pull origin feature_new
git push origin feature_new 
\end{verbatim}

\end{enumerate}

Note that this could also be process could be more direct by pulling from the remote master straight from within your local copy of the `feature\_new' branch. Again, there are multiple ways of updating and merging which involve pushing and pulling between different branches that may be local or remote.

Lastly, once you are finished developing your new feature and have merged your work from the `feature\_new' branch into the master, you can delete the branch from the remote repository with
\begin{verbatim}
git push origin :feature_new
\end{verbatim}



\section*{\TitleFont{Compiling and running HiFiLES}}

Needs to be updated...

To specify whether HiFiLES will be compiled for running on CPUs or GPUs, go to \texttt{sd\_b/bin}, open
\texttt{Makefile}, look for the line that says \texttt{NODE=} and set it to \texttt{NODE=CPU} or
\texttt{NODE=GPU}.

To compile, go to directory \texttt{sd\_b/bin} and run
\begin{verbatim}
 make -f Makefile
\end{verbatim}
To run sd++, go to directory \texttt{sd\_b/bin} and run
\begin{verbatim}
 ./sd++_b INPUTFILE
\end{verbatim}
For example
\begin{verbatim}
 ./sd++_b ../examples/input_sphere_hex_inv
\end{verbatim}

\section*{\TitleFont{Some nomenclature}}

\begin{tabular}{l l l l l}
 \texttt{dis}: & discontinuous & & \texttt{con}:& continuous \\
 \texttt{u}:& solution & & \texttt{f}:& flux \\
 \texttt{t}:& transformed & & \texttt{l,r}:& left, right \\
 \texttt{s}:& shape & & \texttt{norm}:& normal \\
 \texttt{inv}:& inviscid & & \texttt{vis}:& viscous \\
 \texttt{grad}:& gradient & & \texttt{detjac}:& determinant of Jacobian \\
 \texttt{pts}:& points & & \texttt{in}:& input \\
 \texttt{loc}:& location & & \texttt{cub}:& cubature --multidimensional integration \\
 \texttt{bdy}:& boundary of domain  && \texttt{int}:& interior of domain \\
 \texttt{inters}:& interfaces & & \texttt{delta}:& change \\
 \texttt{mag}:& magnitude & & \texttt{dot}:& dot product \\
 \texttt{mul}:& multiplication & & \texttt{jac}:& jacobian \\
 \texttt{lut}:& look up table & & \texttt{temp}:& temporary \\
 \texttt{v,vert}:& vertex & & \texttt{ptr}:& pointer \\
 \texttt{ppt}:& plot points & &  \\
\end{tabular}


\section*{\TitleFont{Main Classes}}
\begin{tabular}{p{4cm} p{12cm}}
 \texttt{{\bf \centering Class}}: & {\bf  Description}\\
 \hline \texttt{array< typename T >}: & stores information in arrays; can be resized and
printed \\
\hline \texttt{input}: & reads and stores values from input file\\
 \hline \texttt{mesh}: & indirectly stores solution and flux values using
 \texttt{array<eles\_type>}; indirectly stores data related to the interfaces using class
\texttt{inters}; stores information about the mesh; advances the solution in time\\
\hline \texttt{eles}: & stores all solution and flux values directly using \texttt{array< double >};
calculates residual in each element (contains the functions that implement the Flux Reconstruction
approach)\\
\hline \texttt{inters}: & stores data related to each interface using class \texttt{array< double
>}; calculates interface fluxes
\end{tabular}

\section*{\TitleFont{Contents of folders in sd++}}
\begin{tabular}{p{4cm} p{12cm}}
 \texttt{{\bf \centering Folder}} & {\bf  Contents}\\
 \hline \texttt{sd\_b/bin} & \texttt{./sd++\_b} executable, Makefile, compiled libraries \\
\hline \texttt{sd\_b/docs/html} & Doxygen documentation; open any html file to navigate\\
 \hline \texttt{sd\_b/examples} & sample input files; mesh files; location of the mesh file is
specified in the input file\\
\hline \texttt{sd\_b/include} & the \texttt{.h} files contain class definitions; the name of each
file is the name of the class it defines \\
\hline \texttt{sd\_b/lib} & libraries for Tecplot 360 and MPI \\
\hline \texttt{sd\_b/src} & \texttt{driver.cpp} contains \texttt{main()}; the other \texttt{.cpp}
files contain the implementation of the member functions
\end{tabular}


\end{document}